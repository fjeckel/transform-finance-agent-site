import { ResearchSession, ExportFormat, AIResult } from '@/types/research';

interface ExportData {
  session: ResearchSession;
  claudeResult?: AIResult;
  openaiResult?: AIResult;
  comparisonAnalysis?: any;
}

export class ExportService {
  
  /**
   * Export research results in specified format
   */
  static async exportResearch(
    session: ResearchSession, 
    format: ExportFormat
  ): Promise<{ success: boolean; blob?: Blob; error?: string }> {
    
    try {
      const exportData: ExportData = {
        session,
        claudeResult: session.results?.claude,
        openaiResult: session.results?.openai,
        comparisonAnalysis: session.comparison
      };

      switch (format) {
        case 'pdf':
          return await this.exportToPDF(exportData);
        case 'docx':
          return await this.exportToDocx(exportData);
        case 'markdown':
          return await this.exportToMarkdown(exportData);
        case 'json':
          return await this.exportToJSON(exportData);
        default:
          return { success: false, error: 'Unsupported export format' };
      }
      
    } catch (error) {
      console.error('Export error:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Export failed' 
      };
    }
  }

  /**
   * Generate markdown content for export
   */
  private static generateMarkdownContent(data: ExportData): string {
    const { session, claudeResult, openaiResult, comparisonAnalysis } = data;
    
    let markdown = '';
    
    // Header
    markdown += `# AI Research Analysis Report\n\n`;
    markdown += `**Topic:** ${session.topic}\n`;
    markdown += `**Generated:** ${new Date().toLocaleDateString()}\n`;
    markdown += `**Total Cost:** $${session.totalCost?.toFixed(4) || '0.0000'}\n`;
    markdown += `**Processing Time:** ${session.processingTime ? Math.round(session.processingTime / 1000) : 0} seconds\n\n`;
    
    markdown += `---\n\n`;
    
    // AI-Powered Comparison Analysis (if available)
    if (comparisonAnalysis) {
      markdown += `## ðŸ¤– AI-Powered Professional Analysis\n\n`;
      markdown += `*Generated by Claude â€¢ ${comparisonAnalysis.metadata?.tokensUsed?.toLocaleString() || 'N/A'} tokens â€¢ $${comparisonAnalysis.metadata?.cost?.toFixed(4) || '0.0000'}*\n\n`;
      markdown += `${comparisonAnalysis.content}\n\n`;
      markdown += `---\n\n`;
    }
    
    // Claude Results
    if (claudeResult) {
      markdown += `## ðŸ¤– Claude Analysis\n\n`;
      markdown += `**Model:** ${claudeResult.metadata.model}\n`;
      markdown += `**Tokens Used:** ${claudeResult.metadata.tokensUsed.toLocaleString()}\n`;
      markdown += `**Cost:** $${claudeResult.metadata.cost.toFixed(4)}\n`;
      markdown += `**Processing Time:** ${Math.round(claudeResult.metadata.processingTime / 1000)}s\n\n`;
      markdown += `### Analysis:\n\n`;
      markdown += `${claudeResult.content}\n\n`;
      markdown += `---\n\n`;
    }
    
    // OpenAI Results
    if (openaiResult) {
      markdown += `## âš¡ OpenAI Analysis\n\n`;
      markdown += `**Model:** ${openaiResult.metadata.model}\n`;
      markdown += `**Tokens Used:** ${openaiResult.metadata.tokensUsed.toLocaleString()}\n`;
      markdown += `**Cost:** $${openaiResult.metadata.cost.toFixed(4)}\n`;
      markdown += `**Processing Time:** ${Math.round(openaiResult.metadata.processingTime / 1000)}s\n\n`;
      markdown += `### Analysis:\n\n`;
      markdown += `${openaiResult.content}\n\n`;
      markdown += `---\n\n`;
    }
    
    // Footer
    markdown += `## Report Information\n\n`;
    markdown += `- **Session ID:** ${session.id}\n`;
    markdown += `- **Research Type:** ${session.parameters?.researchType || 'Custom'}\n`;
    markdown += `- **Depth:** ${session.parameters?.depth || 'Comprehensive'}\n`;
    markdown += `- **Target Audience:** ${session.parameters?.targetAudience || 'Executives'}\n`;
    markdown += `- **Generated by:** AI Research Comparator\n`;
    markdown += `- **Export Date:** ${new Date().toISOString()}\n`;
    
    return markdown;
  }

  /**
   * Export to Markdown format
   */
  private static async exportToMarkdown(data: ExportData): Promise<{ success: boolean; blob?: Blob; error?: string }> {
    const content = this.generateMarkdownContent(data);
    const blob = new Blob([content], { type: 'text/markdown' });
    
    this.downloadBlob(blob, `ai-research-${data.session.id}.md`);
    
    return { success: true, blob };
  }

  /**
   * Export to JSON format
   */
  private static async exportToJSON(data: ExportData): Promise<{ success: boolean; blob?: Blob; error?: string }> {
    const jsonData = {
      exportInfo: {
        exportedAt: new Date().toISOString(),
        exportFormat: 'json',
        version: '1.0'
      },
      session: {
        id: data.session.id,
        topic: data.session.topic,
        status: data.session.status,
        totalCost: data.session.totalCost,
        processingTime: data.session.processingTime,
        createdAt: data.session.createdAt,
        parameters: data.session.parameters
      },
      results: {
        claude: data.claudeResult ? {
          content: data.claudeResult.content,
          metadata: data.claudeResult.metadata,
          classification: data.claudeResult.classification,
          timestamp: data.claudeResult.timestamp
        } : null,
        openai: data.openaiResult ? {
          content: data.openaiResult.content,
          metadata: data.openaiResult.metadata,
          classification: data.openaiResult.classification,
          timestamp: data.openaiResult.timestamp
        } : null
      },
      comparisonAnalysis: data.comparisonAnalysis || null
    };
    
    const content = JSON.stringify(jsonData, null, 2);
    const blob = new Blob([content], { type: 'application/json' });
    
    this.downloadBlob(blob, `ai-research-${data.session.id}.json`);
    
    return { success: true, blob };
  }

  /**
   * Export to PDF format (using HTML to PDF conversion)
   */
  private static async exportToPDF(data: ExportData): Promise<{ success: boolean; blob?: Blob; error?: string }> {
    // Convert markdown to HTML for better PDF formatting
    const markdownContent = this.generateMarkdownContent(data);
    const htmlContent = this.markdownToHTML(markdownContent);
    
    // Create a temporary window for printing
    const printWindow = window.open('', '_blank');
    if (!printWindow) {
      return { success: false, error: 'Could not open print window' };
    }
    
    printWindow.document.write(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>AI Research Analysis Report</title>
          <style>
            body { 
              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
              line-height: 1.6; 
              max-width: 800px; 
              margin: 0 auto; 
              padding: 20px;
              color: #333;
            }
            h1 { color: #2563eb; border-bottom: 2px solid #2563eb; padding-bottom: 10px; }
            h2 { color: #7c3aed; margin-top: 30px; }
            h3 { color: #059669; }
            pre { 
              background: #f8f9fa; 
              padding: 15px; 
              border-radius: 5px; 
              overflow-wrap: break-word;
              white-space: pre-wrap;
            }
            .metadata {
              background: #e5f3ff;
              padding: 10px;
              border-radius: 5px;
              margin: 10px 0;
            }
            hr { border: 1px solid #e5e7eb; margin: 30px 0; }
            @media print {
              body { margin: 0; padding: 15px; }
              .no-print { display: none; }
            }
          </style>
        </head>
        <body>
          ${htmlContent}
          <br/>
          <div class="no-print" style="text-align: center; margin-top: 30px;">
            <button onclick="window.print(); setTimeout(() => window.close(), 1000);" 
                    style="background: #2563eb; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">
              Print to PDF
            </button>
          </div>
        </body>
      </html>
    `);
    
    printWindow.document.close();
    
    return { success: true };
  }

  /**
   * Export to DOCX format (simplified HTML download for now)
   */
  private static async exportToDocx(data: ExportData): Promise<{ success: boolean; blob?: Blob; error?: string }> {
    // For now, we'll create an HTML file that can be opened in Word
    // In a production app, you'd use a library like docx or mammoth
    const markdownContent = this.generateMarkdownContent(data);
    const htmlContent = this.markdownToHTML(markdownContent);
    
    const docContent = `
      <!DOCTYPE html>
      <html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word">
        <head>
          <meta charset="utf-8">
          <title>AI Research Analysis Report</title>
          <!--[if gte mso 9]>
          <xml>
            <w:WordDocument>
              <w:View>Print</w:View>
              <w:Zoom>90</w:Zoom>
              <w:DoNotPromptForConvert/>
              <w:DoNotShowInsertionsAndDeletions/>
            </w:WordDocument>
          </xml>
          <![endif]-->
          <style>
            body { font-family: Calibri, sans-serif; line-height: 1.6; }
            h1 { color: #2563eb; }
            h2 { color: #7c3aed; }
            h3 { color: #059669; }
            pre { background: #f8f9fa; padding: 15px; border: 1px solid #e5e7eb; }
          </style>
        </head>
        <body>
          ${htmlContent}
        </body>
      </html>
    `;
    
    const blob = new Blob([docContent], { 
      type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
    });
    
    this.downloadBlob(blob, `ai-research-${data.session.id}.doc`);
    
    return { success: true, blob };
  }

  /**
   * Simple markdown to HTML converter
   */
  private static markdownToHTML(markdown: string): string {
    return markdown
      // Headers
      .replace(/^### (.*$)/gm, '<h3>$1</h3>')
      .replace(/^## (.*$)/gm, '<h2>$1</h2>')  
      .replace(/^# (.*$)/gm, '<h1>$1</h1>')
      // Bold
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      // Italic  
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      // Code blocks
      .replace(/```[\s\S]*?```/g, (match) => {
        const code = match.replace(/```/g, '');
        return `<pre>${code}</pre>`;
      })
      // Horizontal rules
      .replace(/^---$/gm, '<hr>')
      // Line breaks
      .replace(/\n/g, '<br>');
  }

  /**
   * Download blob as file
   */
  private static downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}